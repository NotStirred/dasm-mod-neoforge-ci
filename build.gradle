plugins {
    id 'java-library'
    id 'maven-publish'
    id 'net.neoforged.moddev' version '2.0.123'
    id 'idea'
}

tasks.named('wrapper', Wrapper).configure {
    // Define wrapper values here so as to not have to always do so when updating gradlew.properties.
    // Switching this to Wrapper.DistributionType.ALL will download the full gradle sources that comes with
    // documentation attached on cursor hover of gradle classes and methods. However, this comes with increased
    // file size for Gradle. If you do switch this to ALL, run the Gradle wrapper task twice afterwards.
    // (Verify by checking gradle/wrapper/gradle-wrapper.properties to see if distributionUrl now points to `-all`)
    distributionType = Wrapper.DistributionType.BIN
}

version = mod_version
group = mod_group_id

repositories {
    mavenLocal()
}

base {
    archivesName = mod_id
}

var isCI = System.getenv("CI") == "true" ?: false
var dasm_version = "3.2.0" // default is only for non-ci situations just so the project works
var neo_version = System.getenv("NEO_VERSION") ?: "21.10.64" // default is only for non-ci situations just so the project works
var minecraft_version = "1." + neo_version.substring(0, neo_version.lastIndexOf('.'))
var java_version = -1

if (neo_version.startsWith("21")) {
    java_version = 21
} else if (neo_version.startsWith("20")) {
    java_version = 17
}

println("DASM Version      : $dasm_version")
println("NEO Version       : $neo_version")
println("Minecraft Version : $minecraft_version")
println("Java Version      : $java_version")

java.toolchain.languageVersion = JavaLanguageVersion.of(java_version)

neoForge {
    version = neo_version

    runs {
        client {
            client()
            systemProperty 'forge.enabledGameTestNamespaces', project.mod_id
        }
    }

    mods {
        // define mod <-> source bindings
        // these are used to tell the game which sources are for which mod
        // multi mod projects should define one per mod
        "${mod_id}" {
            sourceSet(sourceSets.main)
        }
    }

    unitTest {
        enable()
        testedMod = mods.examplemod
    }
}

// Include resources generated by data generators.
sourceSets.main.resources { srcDir 'src/generated/resources' }

// Sets up a dependency configuration called 'localRuntime'.
// This configuration should be used instead of 'runtimeOnly' to declare
// a dependency that will be present for runtime testing but that is
// "optional", meaning it will not be pulled by dependents of this mod.
configurations {
    runtimeClasspath.extendsFrom localRuntime
}

dependencies {
    compileOnly("io.github.notstirred:dasm:$dasm_version:api")
    if (!isCI) { // in CI the dasm jar gets placed in the mods folder
        runtimeOnly("io.github.notstirred:dasm-neoforge:$dasm_version")
    }

    testImplementation("org.junit.jupiter:junit-jupiter-api:5.13.0")
    testImplementation("org.junit.jupiter:junit-jupiter-params:5.13.0")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.13.0")
    testRuntimeOnly "org.junit.platform:junit-platform-launcher"
}

// This block of code expands all declared replace properties in the specified resource targets.
// A missing property will result in an error. Properties are expanded using ${} Groovy notation.
var generateModMetadata = tasks.register("generateModMetadata", ProcessResources) {
    var replaceProperties = [
            minecraft_version      : "$minecraft_version",
            minecraft_version_range: "[$minecraft_version]",
            neo_version            : "$neo_version",
            mod_id                 : mod_id,
            mod_name               : mod_name,
            mod_license            : mod_license,
            mod_version            : mod_version,
            mod_authors            : mod_authors,
            mod_description        : mod_description,
    ]
    inputs.properties replaceProperties
    expand replaceProperties
    from "src/main/templates"
    into "build/generated/sources/modMetadata"
}
// Include the output of "generateModMetadata" as an input directory for the build
// this works with both building through Gradle and the IDE.
sourceSets.main.resources.srcDir generateModMetadata
// To avoid having to run "generateModMetadata" manually, make it run on every project reload
neoForge.ideSyncTask generateModMetadata

test {
    useJUnitPlatform()

    testLogging {
        events("passed", "skipped", "failed")
        showStandardStreams = true
    }

    jvmArgs("-ea", "-Dmixin.debug.verbose=true", "-Dmixin.debug.export=true", "-Dmixin.checks.interfaces=true")

}
